#include<iostream>
#include<Windows.h>
#include<math.h>
/*-----------------------------------------------------------*/
int main()
{
	using namespace std;
	// 内联函数
	// -内联函数是C++为提高程序运行速度所做的一项改进
	// -常规函数和内联函数之间的主要区别不在于编写方式
	// -而在于C++编译器如何将他们组合到程序中
	// -具体原理看书P270
	// 使用这项特性,必须采取下属措施之一：
	// ~在函数声明前加上关键字inline
	// ~在函数定义前加上关键字inline
	// 通常做法是省略原型,将整个定义(即函数头和所有函数代码)放在本应提供原型的地方
	// 编译器不一定会满足内联的要求,内联函数不能递归
	// -内联函数和常规函数一样,也是按值来传递参数的

	// C语言使用预处理器#define来提供宏――内联函数的原始实现
	// 如下是一个计算平方的宏
	// #define SQUARE(X) X*X
	// 这并不是通过传递参数实现的,而是通过文本替换来实现的――X是"参数"的符号标记
	// a = SQUARE(5.0); is replaced by a = 5.0*5.0
	// b = SQUARE(4.5 + 7.5); is replaced by a = 4.5 + 7.5*4.5 + 7.5
	// c = SQUARE(c++); is replaced by a = c++*c++
	// 这只有第一个能正常工作
	// 也可以通过使用括号来进行改进
	// #define SQUARE(X) ((X)*(X))
	// 但仍然存在宏不能按值传递的问题
	// 所以如果使用C语言的宏执行了类似的函数功能,应考虑将他们转换为C++的内联函数

	// 引用变量
	// 引用是已定义变量的别名
	// 引用变量主要用途是用作函数的形参
	int rats;
	int& rodents = rats;
	// &是类型标识符的一部分,int &指的是指向int的引用
	// rats和rodents只想相同的值和存储单元
	// 引用变量必须在声明引用时将其初始化,而不能像指针那样先声明再赋值
	// 一旦与某个变量关联起来,就将一直效忠于它
	int* pt = &rats;
	int& rodents1 = *pt;
	int bunnies = 50;
	pt = &bunnies;
	// 改变pt所指向的地址不会改变rodents的引用是rats

	// 将引用变量作为函数参数
	// 这种传递称为按引用传递
	// 如果实参与引用参数不匹配,C++将生成临时变量,并让参数来引用该变量
	// 当然仅当参数为const引用时,C++才允许这样做
	
	// 如果引用参数是const,则编译器将在下面两种情况生成临时变量
	//-实参的类型正确,但不是左值
	//-实参的类型不正确,但可以转换为正确的类型
	// 左值参数是可被引用的数据对象,例如,变量、数组元素、结构成员、引用和接触引用的指针 都是左值
	// 非左值包含字面常数(用引号括起来的字符串除外,它们由取地址表示)和包含多项的表达式

	// C++新增的另一种引用――右值引用
	// 这种引用可指向右值,是使用&&声明的
	double&& rref = sqrt(36.00);
	double j = 15.0;
	double&& jref = 2.0 * j + 18.5;
	cout << rref << endl;
	cout << jref << endl;
	// 新增右值引用的主要目的是让库设计人员能够提供有些操作的更有效的实现

	// string类定义了一种char *到string的转换功能,这使得可以使用C-风格字符串来初始化string对象

	// 使得能够将特性从一个类传递给另一个类的语言特性被称为继承
	// 简答地说,ostream是基类(因为ofstream是建立在他的基础之上的)
	// 而ofstream是派生类(因为它是从ostream派生出来的)
	// 派生类继承了基类的方法,这意味着ofstream对象可以使用基类的特性,如格式化方法precision()和setf()
	// 继承的另一个特征是,基类引用可以指向派生类对象,而无需进行强制类型转换
	// 这种特征的一个实际结果是,可以定义一个接受基类引用作为参数的函数,调用函数时,可以将基类对象作为参数
	// 也可以将派生类对象作为参数

	//使用引用参数的主要原因有两个
	//	-程序员能够修改调用函数中的数据对象。
	//	-通过传递引用而不是整个数据对象,可以提高程序的运行速度

	//对于使用传递的值而不作修改的函数：
	// -如果数据对象很小,如内置数据类型或小型结构,则按值传
	// -如果数据对象是数组,则使用指针,因为这是唯一的选择,并将指针声明为指向const的指针
	// -如果数据对象是较大的结构,则使用const指针或const引用,以提高程序的效率,这样可以节省复制结构所需的时间和空间。
	// -如果数据对象是类对象,则使用const引用.类设计的语义常常要求使用引用,这是C++新增这项特性的主要原因。
	//  因此,传递类对象参数的标准方式是按引用传递

	//对于修改调用函数中数据的函数：
	// -如果数据对象是内置数据类型,则使用指针.如果到诸如fixit(&x)这样的代码其x是int),
	// 	则很明显,该函数将修改X值 
	// -如果数据对象是数组,则只能使用指针
	// -如果数据对象是结构,则使用引用或指针
	// -如果数据对象是类对象,则使用引用

	// 默认参数
	// 默认参数是指当函数调用中省略了实参时自动使用的一个值
	
	// 如何让设置默认参数
	// 必须通过函数原型
	// 由于编译器通过查看原型来了解函数所使用的参数数目,因此函数原型也必须将可能的默认参数告知程序
	char* left(const char* str, int n = 1);
	// 对于带参数列表的函数,必须从右向左添加默认值
	int harpo(int n, int m = 4, int j = 5);	//valid
	//int chico(int n, int m = 4, int j);	//invalid

	// 在设计类时通过使用默认参数可以减少要定义的析构函数、方法以及方法重载的数量


	// 函数重载
	// 函数重载的关键是函数的参数列表――也称为函数特征标
	// 如果两个函数的参数数目相同和类型相同,同时参数的排序顺序也相同,则他们的特征标相同
	// 而变量名时无关将要的
	
	// 引用和原型视为一个,const与非const是区分的

	// 注:是特征标,而不是函数类型使得可以对函数进行重载

	// 名称修饰
	// 使用C++开发工具中的编辑器编写和编译程序时,C++编译器将执行一些神奇的操作----名称修饰(name decoration )或名称矫正(name mangling)
	// 它根据函数原型中指定的形参类型对每个函数名进行加密
	// 未经修饰的函数原型:long MyFunction(int, float);
	// 而编译器将名称转换为不太好看的内部表示,来描述该接口:
	// ?MyFunction@@YAXH
	
	// 函数模板 
	// 函数模板是通用的函数描述,也就是说,它们使用泛型来定义函数,其中的泛型可用具体的类型(如int或double)替换
	// 通过将类型作为参数传递给模板,可使编译器生成该类型的函数
	// 函数模板允许以任意类型的方式来定义函数
	/*
	template<typename AnyType>
	void Swap(AnyType& a, AnyType& b)
	{
		...
	}
	*/
	// 第一行指出,要建立一个模板,并将类型命名为AnyType
	// 关键字template,typename是必需的,除非可以使用关键字class代替typename
	// 必须使尖括号
	// 类型名可以任意选择(这里为AnyType),只要遵守C++命名规则即可
	// 模板并不创建任何函数,而只是告诉编译器如何定义函数

	// 在标准C++98添加关键字typename之前,C++使用关键字class来创建模板,可以这样编写模板定义
	// template<class AnyType>

	// 函数模板不能缩短可执行程序
	// 更常见的情形是,将模板放在头文件中,并在需要使用模板的文件中包含头文件

	// 重载的模板函数
	// 和常规重载一样被重载的模板的函数特征必须不同
	// 如 Swap(T&, T&)和 Swap(T[], T[], int)
	// 并非所有的模板参数都必须是模板参数类型

	// 模板类的局限性
	// 假如有以下模板
	// template<class T>
	// void f(T a, T b) {...}
	// 假定代码定义赋值,但如果T为数组,这种假设将不成立
	// 假定代码定义运算符>,但如果T为结构,也不成立
	// 编写的模板函数可能无法处理某些类型
	// 一种解决方案就是C++允许重载运算符+来处理特定的结构或类
	// 另一种解决方案是为特定类型提供具体的模板定义

	// 显式具体化
	// 其中包含所需的代码.当编译器找到与函数调用匹配的具体化定义时,将使用该定义,而不再寻找模板
	// 第三代具体化(ISO/ANSI C++标准)
	// 试验其他具体化方法后,C++98标准选择了下面的方法
	// -对于给定的函数名,可以有非模板函数、模板函数和显式具体化模板函数以及它们的重载版本
	// -显式具体化的原型和定义应以template<>打头,并通过名称来指出类型
	// -具体化优先于常规模板,而非模板函数优先具体化和常规模板
	struct job {
		string name[20];
		int year;
		int weight;
	};
	// 下面是交换job结构的非模板函数、模板函数和具体化原型:
	// non template function prototype
	/*
	void Swap(job&, job&);
	*/

	// template prototype
	/*
	template <typename T>
	void Swap(T &, T &);
	*/

	// esplicit specialization for the job type
	/*
	template <> void Swap<job>(job&, job&);
	*/

	// 如有多个原型,则编译器在选择原型时,非模板版本优先于显式具体化和模板版本
	// 而显式具体化优先于使用模板生成的版本

	// Swap<job>中的<job>是可选的,因为函数的参数类型表明,这个job是一个具体化
	// template <> void Swap (job &, job &);

	// 实例化
	// 在代码中包含函数模板本身并不会生成函数定义,它只是一个用于生成函数定义的方案
	// 编译器使用模板为特定类型生成函数定义时,得到的是模板实例(instantiation)

	// 可使用函数创建显式实例化
	/*
	template<class T>
	 T Add(T a, T b)
	 {
			return a + b;
	 }

	 int m = 6;
	 double x = 10.2;
	 cout << Add<double>(x.m) << endl;
	 */
	// 这里的模板与函数调用Add(x m)不匹配,因为该模板要求两个函数参数的类型相同
	// 但通过使用Add<double>(x, m),可强制为double类型实例化,并将参数m强制转换为double类型
	// 以便与函数Add<double>(double, double)的第二个参数匹配

	// 隐式实例化、显式实例化和显式具体化统称为具体化(specialization)
	// 它们的共同之处在于,它们表示的都是使用具体类型的函数定义,而不是通用描述

	// 引入显式实例化后,必须使用新的语法――在声明中使用前缀 template 和 template <> ,以区分显式实例化和显式具体化
	
	// 对于函数重载、函数模板和函数模板重载，C++需要(且有)一个定义良好的策略,来决定为函数
	// 调用使用哪个函数定义,尤其是有多个参数时
	// 这个过程称为重载解析(overloading resolution)

	/*
	template<class T1, class T2>
	void ft(T1 x, T2 y)
	{
		xpy = x + y;
	}
	*/
	// xpy的类型不能够确定

	// 关键词 decltype (C++11)
	int x;
	decltype(x) y; // make y the same type as x
	// 给 decltype 提供的参数可以是表达式
	// 因此在前面的模板函数ft()中,可使用下面的代码
	decltype(x + y) xpy; // make xpy the same type as x+y
	xpy = x + y;
	// 另一种方法是,将这两条语句合而为一
	// decltype(x + y) xpy = x + y;

	// decltype(expression) var;
	// 则核对表的简化版如下
	// 第一步:如果expression是一个没有用括号括起的标识符,则var的类型与该标识符的类型相同,包括const、&等限定符
	// 第二步:如果expression是一个函数调用,则 ar的类型与函数的返回类型相同
	//        注:并不会实际调用函数.编译器通过查看函数的原型来获悉返回类型,而无需实际调用函数
	// 第三步:如果expression是一个左值,则var为指向其类型的引用
	// 第四步:如果前面的条件都不满足,则var的类型与expression的类型相同

	// 如果需要多次声明,可结合使用typedef和decltype:
	/*
		template<class T1, class T2>
		void ft(T1 z, T2 y)
		{
			...
			typedef decltype(x + y) xytype;
			xytype xpy = x + y;
			xytype arr[10];
			xytype & rxy = arr[2];
		}
	*/

	// C++11后置返回类型
	/*
		template<class T1, class T2>
		?type? ft(T1 x, T2 y)
		{
			...
			return x + y;
		}
	*/
	// 同样无法预先知道将x和y相加得到的类型
	// 好像可以将返回类型设置为decltype(x + y),但不幸的是,此时还未声明参数x和y,它们不在作用域内(编译器看不到它们,也无法使用它们)
	// 必须在声明参数后使用decltype

	// 下面使用内置类型来来明这种语法的工作原理
	// 对于下面的原型：
	double h(int x, float y);
	// 使用新增的语法可编写成这样:
	auto h(int x, float y)->double;

	// 这将返回类型移到参数声明后面
	// ->double被称为后置返回类型(trailing return type)
	// auto是一个占位符,表示后置返回类型提供的类型

	// 通过结合使用这种语法和decltype,可给gt()定返回类型,如下所示:
	/*
		template<class T1, class T2>
		auto gt(T1 x, T2 y) -> decltype(x + y)
		{
			...
			return x + y;
		}
	*/


	system("pause");
	return 0;
}