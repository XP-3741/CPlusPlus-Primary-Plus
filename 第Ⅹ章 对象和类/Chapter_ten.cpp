#include<iostream>
#include<Windows.h>
#include<cctype>
#include"stock.h"
#include"stack.h"

int main()
{
	// OOP特性：
	// ・抽象
	// ・封装和数据隐藏
	// ・多态
	// ・继承
	// ・代码的可重用性
	
	// 类是一种将抽象转换为用户定义类型的C++工具
	// 它将数据表示和操纵数据的方法组合成-个整洁的包

	// 类规范由两个部分组成:
	// ~ 类声明:以数据成员的方式描述数据部分,以成员函数(被称为方法)的方式描述公有接口 
	// ~ 类方法定义:描述如何实现类成员函数
	// 简单地说,类声明提供了类的蓝图,而方法定义则提供了细节

	// 接口:是一个共享框架,供两个系统(如在计算机和打印机之间或者用户或计算机程序之间)交互时使用
	// 对于类,我们说公共接口
	// 公众(public)是使用类的程序,交互系统由类对象组成,而接口由编写类的人提供的方法组成
	// 接口让程序员能够编写与类对象交互的代码,从而让程序能够使用类对象
	// 例如,要计算string对象中包含多少个字符,无需打开对象,而只需使用string类提供的size()方法
	// 方法size()是用户和string类对象之间的公共接口的组成部分
	
	// 通常,C++程序员将接口(类定义)放在头文件中,并将实现(类方法的代码)放在源代码文件中
	// 1.访问控制
	// 关键字private,public,描述了对类成员的访问限制
	// 使用类对象的程序都可以直接访问公有部分,但只能通过公有成员函数(或友元函数)来访问对象的私有成员
	// 公有成员函数是程序和对象的私有成员之间的桥梁,提供了对象和程序之间的接口
	// 防止程序直接访问数据被称为 数据隐藏
	// C++还提供了第三个访问控制关键字 protected

	// 类设计尽可能将公有接口与实现细节分开
	// 公有接口表示设计的抽象组件
	// 将实现细节放在一起并将它们与抽象分开被称为封装
	// 数据隐藏(将数据放在类的私有部分中)是一种封装
	// 将实现的细节隐藏在私有部分中,也是一种封装
	// 封装的另一个例子是,将类函数定义和类声明放在不同的文件中
	
	// 2.控制对成员的访问:公有还是私有
	// 无论类成员是数据成员还是成员函数,都可以在类的公有部分或私有部分中声明
	// 但由于隐藏数据是OOP主要的目标之一
	// 因此数据项通常放在私有部分,组成类接口的成员函数放在公有部分
	// 否则就无法从程序中调用这些函数
	// 也可以把成员函数放在私有部分中.不能直接从程序中调用这种函数,但公有方法却可以使用它们
	// 通常.程序员使用私有成员函数来处理不属于公有接口的实现细节

	// 不必在类声明中使用关键字private,因为这是类对象的默认访控制

	// C++对结构进行了扩展,使之具有与类相同的特性
	// 它们之间唯一的区别是,结构的默认访问类型是 public ,而类为 private
	// C++程序员通常使用类来实现类描述,而把结构限制为只表示纯粹的数据对象
	// （常被称为普通式数据(POD, Plain Old Data)结构）

	// 实现类成员函数
	// 还需要创建类描述的第二部分:为那些由类声明中的原型表示的成员函数提供代码
	// 成员函数定义与常规函数定义非常相似,它们有函数头和函数体,也可以有返回类型和参数
	// 但是它们还有两个特殊的特征:
	// ~定义成员函数时,使用作用域解析运算符(::)来标识函数所属的类
	// ~类方法可以访问类的 private 组件

	// 首先,成员函数的函数头使用作用域运算符解析(::)来指出函数所属的类
	// 例如 update() 成员函数的函数头如下:
	// void Stock::update(double price);
	// 这种表示法意味着我们定义的 update() 函数是 Stock 类的成员
	// 这不仅将 update() 标识为成员函数,还意味着我们可以将另―个类的成员函数也命名为 update()

	// 作用域解析运算符定义了方法定义对应的类的身份
	// 标识符 update() 有类作用域(class scope)
	// Stock类的其他成员函数不必使用作用域解析运算符,就可以使用update()方法
	// 这是因为它们属于同一个类,因此 update() 是可见的
	// 然而,在类声明和方法定义之外使用update()时,要采用特殊的措施

	// 类方法的完整名称中包括类名
	// Stock::update()是函数的限定名(qualified name)
	// 而简单的update()是全名的缩(非限定名,unqualified name),只能在类作用域中使用

	// 方法的第二个特点是,方法可以访问类的私有成员
	// 如果试图使用非成员函数访问这些数据成员,编译器禁止这样做（但11章中将介绍的友元函数例外)

	// 内联方法
	// 其定义位于类声明中的函数都将自动成为内联函数
	// 类声明常将短小的成员函数作为内联函数
	// 如果愿意,也可以在类声明之外定义成员函数,并使其成为内联函数
	// 为此,只需在类实现部分中定义函数时使用inline限定符即可
	// 内联函数的特殊规则要求在每个使用它们的文件中都对其进行定义
	// 确保内联定义对多文件程序中的所有文件都可用的、最简单的方法是：
	// 将内联定义放在定义类的头文件中
	// (有些开发系统包含智能链接程序,允许将内联定义放在一个独立的实现文件)
	// 顺便一句，根据改写规则(rewrite rule),在类声明中定义方法等同于用原型替换方法定义,
	// 然后在类声明的后面将定义改写为内联函数
	
	// 方法使用哪个对象
	// 下面介绍使用对象时最重要的一个方面：如何将类方法应用于对象
	// 和使用结构成员一样,通过成员运算符：
	// kate.show();
	// 语句调用kate对象的show()成员,这意味着show()方法将shares解释为kate.shares
	// 将share_vla解释为kate.share_val
	// 注意：用成员函数时,它将使用被用淼饔盟的对象的数据成员
	
	// 所创建的每个新对象都有自己的存储空间,用于存储其内部变量和类成员
	// 但同一个类的所有对象共享同一组类方法,即每种方法只有一个副本

	// 在OOP中,调用成员函数被称为 发送消息 
	// 因此将同样的消息发给两个不同的对象将调用同一个方法,但该方法被用于两个不同的对象

	// 应为类提供被称为 构造函数 和 析构函数 的标准函数
	// 数据部分的访问状态是私有的,这意味程序不能直接访问数据成员
	// 程序只能通过成员函数来访问数据成员,因此需要设计合适的成员函数,才能成功地将对象初始化

	// 一般来说,最好是在创建对象时对它进行初始化
	// Stock gift;
	// gift.buy(10, 24.75);

	// C++提供了一个特殊的成员函数――类构造函数,专用于构造新对象、将值赋给它们的数据成员
	// 更准确的说,C++为这些成员函数提供了名称和使用语法,而程序员需要提供方法定义
	// 名称与类名相同
	// 例如,Stock类一个可能的构造函数是名为 Stock() 的成员函数
	// 构造函数的原型和函数头有一个有趣的特征――虽然没有返回,但没有被声明为void类型
	// 实际上,构造函数没有声明类型
	
	// 声明和定义构造函数
	// 由于要为Stock对象提供3个值，因此要为构造函数提供3个参数
	// Stock(const string & co, long n = 0, double pr = 0 .0 );
	// 第一个参数是指向字符串的指针,该字符市用于初始化成员company;n和pr参数为shares,share_val成员提供值
	// 注意:没有返回类型且原型位于类声明的公有部分
	// 下面是构造函数的一种可能定义：
	// Stock::Stock(const string & co, long n = 0, double pr = 0 .0 );
	// {
	// company = co;
	// if(n < 0)
	//		shares = 0;
	// else
	//		shares = n;
	// share_val = pr;
	// }
	// 程序声明对象时，将自动调用构造函数
	// 参数名不能与类成员相同
	// 为避免这种混乱,一种常见的做法是在数据成员名中使用"m_"前缀
	// 另一种常见的做法是,在成员名中使用后缀"_"
	
	// 使用构造函数
	// C++提供了两种使用构造函数沓跏蓟对象的方式
	// 第一种方式是显式地调用构造函数:
	// Stock food = Stock("sb", 250, 0.25);
	// 另一种方式是隐式地调用构造函数:
	// Stock garment("dsb", 666, 2.5);
	// 每次创建类对象(甚至使用new动态分配内存)时,C++都使用类构造函数:
	// Stock *pstock = new Stock("djsb", 520, 0.0);
	// 这条语句创建一个Stock对象,将其初始化为参数提供的值,并将该对象的地址赋给pstock指针
	// 在这种情况下,对象没有名称,但可以使用指针来管理该对象
	// 无法使用对象来调用构造函数,因为在构造函数构造出对象之前,对象是不存在的
	// 因此构造函数被用来创建对象,而不能通过对象来调用
	// 接受一个参档墓乖旌数,允许使用赋值语法将对象初始化为一个值
	// Stock you = 25;

	// 默认构造函数
	// 默认构造函数是在未提供显式初始值时,用来创建对象的构造函数
	// 也就是说,它是用于下面这种声明的构造函数:
	// Stock fuck_you;
	// 这条语句管用的原因在于,如果没有提供任何构造函数,则C++将自动提供默认构造函数
	// 它是默认构造函数的隐式版本,不做任何工作
	// 对于Stock类来言,默认构造函数可能如下:
	// Stock::Stock(){}
	// 因此将创建fuck_you对象,但不初始化其成员,这和下面的语句创建x,但没有提供值一样:
	// int x;
	// 奇怪的是,当且仅当没有定义任何构造函数时,编译器才会提供默认构造函数
	// 为类定义了构造函数后,程序员必须为它提供默认构造函数
	// 如果提供了非默认构造函数(如 Stock(const char* co, int n, doublepr)),但没有提供默认构造函数,
	// 则下面的声明将出错:
	// Stock stock1;
	// 这样做的原因可能是想禁止创建未初始化的对象
	// 如果要创建对象,而不显式地初始化,则必须定义一个不接受任何参数的默认构造函数
	// 定义默认构造函数的方式有两种:
	// 一种是给己有构造函数的所有参数提供默认值:
	// Stock(const string & co = "error", int n = 0, double pr = 0.0);
	// 另一种方式是通过函数重载来定义另一个构造函数――一个没有参数的构造函数:
	// Stock();
	// 由于只能有一个默认构造函数,因此不要同时采用这两种方式
	// 实际上,通常应初始化所有的对象,以确保所有成员一开始就有已知的合理值
	// 因此,用户定义的默认构造函数通常给所有成员提供隐式初始值
	// 例如,下面是为Stock类定义的一个默认构造函数:
	// Stock::Stock()
	// {
	//		cpmpant = "sb";
	//		shares = 0;
	//		share_val = 0.0;
	// }
	// 提示:在设计类时,通常应提供对所有类成员做隐式初始化的默认构造函数
	// 使用上述任何一种方式(没有参数或所有参数都有默认值)创建了默认构造函数后
	// 可以声明对象变量,而不对它们进行显式初始化
	// 隐式地调用默认构造函数时,不要使用圆括号:
	// Stock second();
	// 声明指出,second()是一个返回Stock对象的函数

	// 析构函数
	// 用构造函数创建对象后,程序负责跟踪该对象,直到其过期为止
	// 对象过期时,程序将自动调用一个特殊的成员函数,该函数的名称令人生畏――析构函数
	// 析构函数完成清理工作
	// Stock的构造函数没有使用new,因此析构函数实际上没有需要完成的任务
	// 在这种情况下,只需让编译器生成一个什么不要做的隐式析构函数即可
	// 构造函数一样,析构函数的名称也很特殊:在类名前加上~
	// 因此,Stock类的析构函数为~Stock()
	// 另外,和构造函数一样,析构函数也可以没有返回值和声明类型
	// 与构造函数不同的是,析构函数没有参数,因此Stock析构函数的原型必须是这样的:
	// ~Stock();
	// 由于Stock的析构函数不承担任何重要的工作,因此可以将它编写为不执行任何操作的函数:
	// Stock::~Stock()
	// {
	// }
	// 然而,为让能看到析构函数何时被调用,这样编写其代码：
	// Stock::~Stock()
	// {
	//		cout << "bye" << endl;
	// }
	// 什么时候应调用析构函数呢？
	// 这由编译器觉定,通常不应在代码中显式地调用析构构函
	// 如果创建的是静态存储类对象,则其析构函数将在程序结束时自动被调用
	// 如果创建的是自动存储类对象,则其析构函数将在程序执行完代码块时(该对象是在其中定义的)自动被调用
	// 如果对象是通过 new 创建的,则它将驻留在栈内存或自由存储区中,当使用 delete 来释放内存时,其析构函数将自动被调用
	// 最后,程序可以创建临时对象来完成特定的操作,在这种情况下,程序将在结束对该对象的使用时自动调用其析构函数
	// 由于对象过期时析构函数将自动调用,因此必须有一个析构函数
	// 如果没有提供析构函数,编译器将隐式的声明一个默认析构函数,并在发现导致对象被删除的代码后
	// 提供默认析构函数的定义

	std::cout << "Using constructor to create new objects\n";
	Stock stock("NanoSmart", 12, 20.0);
	stock.show();
	std::cout << std::endl;

	Stock sb = Stock("lsp", 666, 6.6);
	// C++标准允许编译器使用两种方式来执行第二种语法
	// 一种是使其行为和第一种语法[Stock stock("NanoSmart", 12, 20.0)]完全相同(VS2019用的这种)
	// 另一种方式是允许调用构造函数泶唇ㄒ桓隽偈倍韵,然后将该临时对象复制到 sb 中,并丢弃它
	// 如果编译器使用的是这种方式,则将为临时对象调用析构函数
	sb = stock;
	// 在默认情况下,将一个对象赋给同类型的另一个对象时,C++将源对象的每个数据成员的内容
	// 复制到目标对象中相应的数据成员中
	sb.show();
	std::cout << std::endl;

	sb = Stock("sb", 250, 25.0);
	// 构造函数不仅仅可用于初始化新对象
	// sb 对象已经存在,因此这条语句不是对 sb 进行初始化,而是将新值赋给它
	// 这是通过让构造程序创建一个新的、临时的对象,然后将其内容复制给 sb 来实现的
	// 随后程序调用析构函数,以删除该临时对象
	// 
	sb.show();
	std::cout << "done!\n";
	std::cout << std::endl;
	// 由于这种自动变量被放在栈中,因此最后创建的对象将最先被删除,最先创建的对象将最后被删除

	// 提示:如果既可以通过初始化,也可以通过赋值来设置对象的值,则应采用初始化方式---通常这种方式的效率更高

	// C++列表初始化
	// 只要提供与某个构造函数的参数列表匹配的内容,并用大括号将它们括起,就可将列表初始化语法用于类吗
	Stock ddjj = { "sdsd",100,45.0 };
	Stock djjj = { "sddd" };

	const Stock py = Stock{ "sb" };
	std::cout << std::endl;
	// py.show();
	// 对于当前的C++来说,编译器将拒绝第二行
	// 我们以前通过将函数参数声明为const引用或指向const的指针来解决
	// 这种问题,但这里存在语法问题:show()方法没有任何参数
	// 因为show()的代码无法确保调用对象不被修改---调用对象和const一样,不应被修改
	// 需要一种新的语法---保证函数不会修改调用对象
	// C++的解决方法是将const关键字放在函数的括号后面
	// 也就是说show()声明应像这样:
	// void show() const;
	// 同样,函数定义的开头应像这样:
	// void stock::show() const;
	// 以这种方式声明和定义的类函数被称为 const成员函数
	// 像应尽可能将const引用和指针用作函数形参一样,只要类方法不修改调用对象,应将其声明为const
	
	// this指针
	// 首先,如何将两个要比较的对象提供给成员函数
	// 假设将该方法命名为topval(),则函数调用stock1.topval()将访stock1对象的数据，而stock2.topval()将访stock2对象的数据
	// 如果希望该方法对两个对象进行比较,则必须将二个对象作为参数传递给它
	// 出于效率方面的考虑,可以按引用泶参数,也就是topval()方法使用一个类型为 const Stock & 的参数
	// 其次,如何将方法的答案传回给调用的程序呢
	// 最直接的方法是让方法返回一个引用,原型如下
	// const Stock & topval(const Stock & s) const;
	// 该函数隐式地访问一个对象,而显式地访问另一个对象,并返回其中一个对象的引用
	// 括号中的const表明,该函数不会修改被显示地访问的对象
	// 括号后的const表明,该函数不会修改被隐示地访问的对象
	// 由于该函数返回了两个const对象之一的引用,因此返回类型也应为const引用
	// 可如下比较
	// top = stock1.topval(stock2);		stock1隐式地访问,stock2显式地访问
	// top = stock2.topval(stock1);		stock2隐式地访问,stock1显式地访问

	// this指针指向用淼饔贸稍焙数的对象(this被作为隐藏参数传递给方法)
	// 一般来说,所有的类方法都将this指针设置为调用它的对象的地址
	// const Stock & Stock::topval(const Stock & s) const
	// {
	//		if(s.total_val > total_val)
	//			return s;
	//		else
	//			return *this;
	// }
	// topval()中的 total_val 就是 this->total_val的简写

	// 每个成员函(包括构造函数和析构函数)都有一个this指针
	// 如果方法需要引用整个调用对象,则可以使用表达式 *this
	// 在函数的括号后面使用 const限定符 将this限定为const,这样将不能使用this来修改对象的值
	// 返回类型为引用意味着返回的是调用对象木身,而不是其副本

	// 对象数组
	Stock mystuff[4];
	// 前面讲过,当程序创建未被显式初始化的类对象时,总是调用默认构造函数
	// 上述声明要求,这个类要么没有显式地定义任何构造函数
	// (在这种情况下,将使不执行任何操作的隐式默认构造函数)
	// 要么定义了一个显式默认构造函数(就像这个例子那样)
	// 每个元素都是Stock对象,可以使用Stock方法
	mystuff[0].update(10.0);
	mystuff[3].show();
	const Stock tops = mystuff[2].topval(mystuff[1]);
	std::cout << std::endl;
	// 可以用构造函数沓跏蓟数组元素.在这种情况下,必须为每个元素调用构造函数:
	const int STKS = 5;
	Stock stocks[STKS] = {
		Stock(),
		Stock("dj"),
		Stock("cx",20.5),
		Stock("tzw",55.5,23)
	};
	std::cout << std::endl;
	// 这里的代码使用标准格式对数组进行初始化：用括号括起的、以逗号分隔的值列表
	// 初始化对象数组的方案是,首先使用默认构造函数创建数组元素
	// 然后花括号中的构造函数将创建临时对象,然后将临时对象的内容复制到相应的元素中
	// 因此,要创建类对象数组,则这个类必须有默认构造函数。
	for (int i = 0; i < STKS; i++)
		stocks[i].show();

	const Stock* topp = &stocks[0];
	for (int i = 1; i < STKS; i++)
		topp = &topp->topval(stocks[i]);
	std::cout << "\nMost valuable holding:\n";
	topp->show();

	// 作用域为类的常量
	// private:
	//		const int Month = 12;
	//		double costs[Month];
	// 这样是行不通的,因为声明类只是描述了对象的形式,并没有创建对象
	// 因此,在创建对象前,将没有用于存储值的空间
	// 有两种方式可以实现这个目标,并且效相同:
	// 1.第一种方式是在类中声明一个枚举
	// 在类声明中声明的枚举的作用域为整个类,因此可以用枚举为整型常景提供作用域为整个类的符号名称
	// private:
	//		enum { Months = 12 };
	//		double costs[Months];
	// 注意,用这种方式声明枚举并不会创建类数据成员
	// 也就是说,所有对象中都不包含枚举
	// 另外, Months 只是一个符号名称,在作用域为整个类的代码中遇到它时,编译器将用 12 来替换它
	// 由于这里使用枚举只是为了创建符号常量,并不打算创建枚举类型的变量,因此不需要提供枚举名
	// 2.C++提供了另一种在类中定义常量的方式---使用关键字 static:
	// private:
	//		static const int Months = 12;
	//		double costs[Months];
	// 这将创建一个名为 Months 的常量,该常量将与其他静态变量存储在一起,而不是存储在对象中

	// 作用域内枚举(C++11)
	// 传统的枚举存在一些问题,其中之一是两个枚举定义中的枚举量可能发生冲突
	// enum egg { Small, Medium, Large, Jumbo };
	// enum t_shirt { Small, Medium, Large, Jumbo };
	// 这将无法通过编译
	// 为避免这种问题C++11提供了一种新枚举,枚举量的作用域为类
	// enum class egg { Small, Medium, Large, Jumbo };
	// enum class t_shirt { Small, Medium, Large, Jumbo };
	// 也可使用关键字 struct 代替 class
	// 无论使用哪种方式,都需要使用枚举名硐薅枚举量
	// egg choice = egg::Large;
	// t_shirt Floyd = t_shirt::Large;
	// C++11还提高了作用域内枚举的类型安全
	// 在有些情况下,常规枚举将自动转换为整型,如将其赋给int变量或用于比较表达式时
	// 但作用域内枚举不能隐式地转换为整型
	// 默认情况下,C++11作用域内枚举的底层类型为 int
	// 另外,还提供了一种语法,可用于做出不同的选择:
	// enum class : short pizza { Small, Medium, Large, Jumbo };
	// :short 将底层类型指定为short,底层类型必须为整型				??????
	// 在C++11中,也可使用这种语法来指定常规枚举的底层类型,但如果没有指定,编译器选择的底层类型将随实现而异

	// 抽象数据类型(abstract data type, ADT)
	// ADT 以通用的方式描述数据类型,而没有引入语言或实现细节

	using namespace std;
	Stack st;	// create an empty stack
	char ch;
	unsigned long po;
	cout << "Please enter A to add a purchase order,\n"
		<< "P to process a PO, or Q to quit.\n";
	while (cin >> ch && toupper(ch) != 'Q') {
		while (cin.get() != '\n')
			continue;
		if (!isalpha(ch)) {
			cout << '\a';
			continue;
		}
		switch (ch)
		{
		case 'A':
		case 'a':
			cout << "Enter a PO number to add: ";
			cin >> po;
			if (st.isfull())
				cout << "Stack already full\n";
			else
				st.push(po);
			break;
		case 'P':
		case 'p':
			if (st.isempty())
				cout << "stack already empty\n";
			else {
				st.pop(po);
				cout << "PO #" << po << " popped\n";
			}
			break;
		default:cout << "\nquestion\n";
		}
		cout << "Please enter A to add a purchase order,\n"
			<< "P to process a PO, or Q to quit.\n";
	}
	cout << "Bye\n";

	system("pause");
	return 0;
}